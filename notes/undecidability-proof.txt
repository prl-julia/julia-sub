[T] = T
[Top] = Bot
[forall alpha<=u.t] = Tuple{Ref{alpha}, [t]} where alpha>=[u]

[G; alpha <= t] = [G]; alpha >= [t]
[;] = ;

weakening: if E |- t1 <:_J t2 -| E', then E;E1 |- t1 <:_J t2 -| E';E1 if 
		forall alpha in E, alpha not in E'
	and t1, t2, WF in E

forward:
(1) G  |-  t1  <:_F  t2 
-> [G] |- [t2] <:_j [t1]

proceed by rule induction on (1)

case NTop: t1 = sigma; t2 = Top; Gamma = ...
wts: [G] |- [Top] <: [sigma]
wts: [G] |- Bot <: [sigma]
trivial by UNION_LEFT

case NRefl: t1 = alpha; t2 = alpha; Gamma = ...
wts: [G] |- [alpha] <: [alpha]
wts: [G] |- alpha <: alpha
holds by REFL

case NVar: t1 = alpha; t2 = tau; Gamma = ...
wts: [G; alpha <= u] |- [tau] <: [alpha]
know: [G]; alpha>=[u] |- [tau] <: [u]
wts: [G; alpha <= u] |- [tau] <: alpha
apply L_RIGHT with l = [u] and follows from IH

case NAll: t1 = forall alpha<=l1.l2, t2 = forall alpha<=r1.r2
by ih: [G] |- [l1] <: [r1] -| [G]
       [G]; alpha>=[r1] |- [r2] <: [l2] 
wts: [G] |- [forall alpha<=r1.r2] <: [forall alpha<=l1.l2]
wts: [G] |- Tuple{Ref{alpha}, [r2]} where alpha>=[r1] <: 
            Tuple{Ref{alpha}, [l2]} where alpha>=[l1] 
L_INTRO:
wts: [G]; L^alpha>=[r1] |- Tuple{Ref{alpha}, [r2]} <: 
                         Tuple{Ref{alpha}, [l2]} where alpha>=[l1] 
R_INTRO:
wts: [G]; L^alpha>=[r1]; R^beta>=[l1] |- Tuple{Ref{alpha}, [r2]} <: Tuple{Ref{beta}, [l2[alpha |-> beta]]} 

TUPLE:
wts (1): [G]; L^alpha>=[r1]; R^beta>=[l1] |- Ref{alpha} <: Ref{beta} -| E'
and (2): E' |- [r2] <: [l2[alpha |-> beta]]


(1):
	APP_INV:
	wts (3): [G]; L^alpha>=[r1]; R^beta>=[l1] |- alpha <: beta -| E1
	and (4):                               E1 |- beta <: alpha -| E'
	(3): apply R_RIGHT with [G]; L^alpha>=[r1]; R^beta>=[l1] |- alpha <: Top (by TOP)
		 E1 = [G]; L^alpha>=[r1]; R^(beta>=Union{[l1],alpha})
	(4): wts: [G]; L^alpha>=[r1]; R^(beta>=Union{[l1],alpha}) |- beta <: alpha -| E'
		 try to apply R_LEFT
		 wts: E1 |- Union{[l1], alpha} <: alpha |- E'
		 apply UNION_LEFT, wts:
		 (5) E1 |- [l1] <: alpha -| E1
		 (6) E1 |- alpha <: alpha -| E' (trivial, focus on 5)
		 
		 (5):
		 	E1 |- [l1] <: [r1] -| E1 by IH and weakening; 5 follows from L_RIGHT
		 E' = [G]; L^alpha>=[r1]; R^(Union{[l1],alpha}<=beta<=alpha)
(2):
wts: E' |- [r2] <: [l2[alpha |-> beta]]
apply lemma subst


lemma subst: ? tl <: alpha ? if E[L^alpha>=t] |- t1 <: t2 -| E'[L^alpha>=t] then 
		  E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- 
		  	t1 <: t2[alpha |-> beta] -| E'[...]

REFL:
	(by lemma refl)

L_RIGHT:
	wts: E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- 
			  	t' <: alpha[alpha |-> beta] -| E'[...]
	given E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- 
			  	t' <: t -| E''[...]


	wts: E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- 
			  	t' <: beta -| E'[...]
	to apply R_RIGHT wts: E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- 
			  	t' <: alpha -| E'[...]
	apply L_RIGHT on IH, done

R_L:
	wts: E[L^alpha>=t][R^(Union{tl,alpha})<:beta<:alpha][R^(t1l<:T1<:t1u)] |- 
			  	T1 <: alpha[alpha |-> beta] -| E'[...]
	wts: E[L^alpha>=t][R^(Union{tl,alpha})<:beta<:alpha][R^(t1l<:T1<:t1u)] |- 
			  	T1 <: beta -| E'[...]
	wts: E[L^alpha>=t][R^(Union{tl,alpha})<:beta<:alpha][R^(t1l<:T1<:t1u)] |- 
			  	t1l <: beta -| E'[...]



lemma refl:
forall E, exists E': E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- 
		  	t <: t[alpha |-> beta] -| E'[...]
structural induction on t;
case Any, DataType, Union, UnionAll trivial
case Union{t1,...,tn}:
	wts forall E, exists E':  
		E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- 
		  Union{t1,...,tn} <: Union{t1,...,tn}[alpha |-> beta] -| E'[...]
	given forall E, exists E': 
		E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- 
		  ti <: ti[alpha |-> beta] -| E'[...] for 1<=i<=n
	apply UNION_LEFT repeatedly, concluding with UNION_RIGHT on ih.
case Tuple{a1,...,an}:
		E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- 
		  Union{a1,...,an} <: Union{a1,...,an}[alpha |-> beta] -| E'[...]
	[application of TUPLE on IH]
case name{a1,...,an}:
	[same thing as TUPLE with APP_INV]
case t where t1<:T<:t2:
	wts forall E, exists E':  
		E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- 
		  t where t1<:T<:t2 <: (t where t1<:T<:t2)[alpha |-> beta] -| E'[...]
    wts E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha]; L^(t1<:T<:t2) |-
    	t <: (t where t1<:T<:t2)[alpha |-> beta] -| E'[...]
    	consistent check in R_INTRO ???????? TODO TODO TODO
    wts E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha]; 
    		L^(t1<:T<:t2); R^(t1<:T<:t2) |-
    	t <: t[alpha |-> beta] -| E'[...]
    holds by IH
case T:
	wts: E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- 
			  	alpha <: alpha[alpha |-> beta] -| E'[...]
	wts: E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- alpha <: beta -| E'[...]
	R_RIGHT wts: E[L^alpha>=t][R^(Union{tl,alpha})<=beta<=alpha] |- alpha <: alpha -| E'[...]
	by REFL E'=E
case Type{a}:
	[TYPE_TYPE on IH]


backward: